name: CI/CD Pipeline

on:
  push:
    branches: [main]
    paths: ['code/**']

  workflow_dispatch:
    inputs:
      service:
        description: 'Service to build & deploy'
        required: true
        type: choice
        options:
          - all
          - frontend
          - cartservice
          - checkoutservice
          - currencyservice
          - emailservice
          - adservice
          - paymentservice
          - productcatalogservice
          - recommendationservice
          - shippingservice
          - loadgenerator
      environment:
        description: 'Deploy environment'
        required: true
        type: choice
        options:
          - staging
          - production

env:
  REGISTRY: ghcr.io

jobs:
  # ── Detect which services changed ──
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.detect.outputs.services }}
      namespace: ${{ steps.env.outputs.namespace }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect changed services
        id: detect
        run: |
          ALL_SERVICES="adservice cartservice checkoutservice currencyservice emailservice frontend loadgenerator paymentservice productcatalogservice recommendationservice shippingservice"

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ "${{ inputs.service }}" == "all" ]]; then
              SERVICES="$ALL_SERVICES"
            else
              SERVICES="${{ inputs.service }}"
            fi
          else
            SERVICES=""
            for svc in $ALL_SERVICES; do
              if git diff --name-only HEAD~1 HEAD -- "code/$svc/" | grep -q .; then
                SERVICES="$SERVICES $svc"
              fi
            done
            SERVICES=$(echo "$SERVICES" | xargs)
          fi

          if [ -z "$SERVICES" ]; then
            echo "services=[]" >> $GITHUB_OUTPUT
            echo "No services changed"
            exit 0
          fi

          JSON=$(echo "$SERVICES" | tr ' ' '\n' | jq -R . | jq -sc .)
          echo "services=$JSON" >> $GITHUB_OUTPUT
          echo "Services to build: $SERVICES"

      - name: Set environment
        id: env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "namespace=${{ inputs.environment }}" >> $GITHUB_OUTPUT
          else
            echo "namespace=staging" >> $GITHUB_OUTPUT
          fi

  # ── Build & push to GHCR ──
  build:
    name: Build ${{ matrix.service }}
    needs: changes
    if: needs.changes.outputs.services != '[]'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        service: ${{ fromJson(needs.changes.outputs.services) }}
    steps:
      - uses: actions/checkout@v4

      - uses: docker/setup-buildx-action@v3

      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set build context
        id: ctx
        run: |
          SVC="${{ matrix.service }}"
          IMAGE=$(echo "ghcr.io/${{ github.repository_owner }}/online-boutique/$SVC" | tr '[:upper:]' '[:lower:]')
          echo "image=$IMAGE" >> $GITHUB_OUTPUT
          if [[ "$SVC" == "cartservice" ]]; then
            echo "context=code/cartservice/src" >> $GITHUB_OUTPUT
            echo "dockerfile=code/cartservice/src/Dockerfile" >> $GITHUB_OUTPUT
          else
            echo "context=code/$SVC" >> $GITHUB_OUTPUT
            echo "dockerfile=code/$SVC/Dockerfile" >> $GITHUB_OUTPUT
          fi

      - uses: docker/build-push-action@v6
        with:
          context: ${{ steps.ctx.outputs.context }}
          file: ${{ steps.ctx.outputs.dockerfile }}
          push: true
          tags: |
            ${{ steps.ctx.outputs.image }}:${{ github.sha }}
            ${{ steps.ctx.outputs.image }}:latest
          cache-from: type=gha,scope=${{ matrix.service }}
          cache-to: type=gha,scope=${{ matrix.service }},mode=max

  # ── Update values.yaml, commit & deploy ──
  deploy:
    name: Deploy to ${{ needs.changes.outputs.namespace }}
    needs: [changes, build]
    if: needs.changes.outputs.services != '[]'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: read
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update values.yaml
        run: |
          REPO=$(echo "ghcr.io/${{ github.repository_owner }}/online-boutique" | tr '[:upper:]' '[:lower:]')
          TAG="${{ github.sha }}"

          yq -i ".images.repository = \"$REPO\"" helm-chart/values.yaml

          declare -A KEY_MAP=(
            [adservice]=adService
            [cartservice]=cartService
            [checkoutservice]=checkoutService
            [currencyservice]=currencyService
            [emailservice]=emailService
            [frontend]=frontend
            [loadgenerator]=loadGenerator
            [paymentservice]=paymentService
            [productcatalogservice]=productCatalogService
            [recommendationservice]=recommendationService
            [shippingservice]=shippingService
          )

          SERVICES='${{ needs.changes.outputs.services }}'
          for svc in $(echo "$SERVICES" | jq -r '.[]'); do
            key="${KEY_MAP[$svc]}"
            [ -n "$key" ] && yq -i ".$key.tag = \"$TAG\"" helm-chart/values.yaml
          done

      - name: Commit updated values
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add helm-chart/values.yaml
          git diff --cached --quiet || git commit -m "ci: update image tags [skip ci]"
          git pull --rebase
          git push

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deploy to EKS
        env:
          NAMESPACE: ${{ needs.changes.outputs.namespace }}
        run: |
          aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }}
          helm upgrade --install online-boutique ./helm-chart \
            --namespace $NAMESPACE \
            --create-namespace \
            --wait \
            --timeout 10m

      - name: Verify
        env:
          NAMESPACE: ${{ needs.changes.outputs.namespace }}
        run: |
          kubectl get pods -n $NAMESPACE
          kubectl get svc -n $NAMESPACE
